# -*- coding: utf-8 -*-
#
# This file is part of the SubarrayNode project
#
#
#
# Distributed under the terms of the BSD-3-Clause license.
# See LICENSE.txt for more info.

""" Subarray Node
Provides the monitoring and control interface required by users as well as
other TM Components (such as OET, Central Node) for a Subarray.
"""

from __future__ import print_function
from __future__ import absolute_import

import threading
# PROTECTED REGION ID(SubarrayNode.additionnal_import) ENABLED START #

import random
import string
from concurrent.futures import ThreadPoolExecutor
import json

# Tango imports
import tango
from tango import DebugIt, DevState, AttrWriteType, DevFailed, DeviceProxy, EventType
from tango.server import run,attribute, command, device_property

# Additional import
from . import const
from .const import PointingState
from ska.base.commands import ResultCode, ResponseCommand
from ska.base.control_model import HealthState, ObsMode, ObsState
from ska.base import SKASubarray
from subarraynode.exceptions import InvalidObsStateError
from ska_telmodel.csp import interface

__all__ = ["SubarrayNode", "main"]

csp_interface_version = 0
sdp_interface_version = 0


class SubarrayHealthState:

    @staticmethod
    def generate_health_state_log_msg(health_state, device_name, event):
        if isinstance(health_state, HealthState):
            return (
                const.STR_HEALTH_STATE + str(device_name) + const.STR_ARROW + str(health_state.name.upper()))
        else:
            return const.STR_HEALTH_STATE_UNKNOWN_VAL + str(event)

    @staticmethod
    def calculate_health_state(health_states):
        """
        Calculates aggregated health state of Subarray.
        """
        unique_states = set(health_states)
        if unique_states == set([HealthState.OK]):
            return HealthState.OK
        elif HealthState.FAILED in unique_states:
            return HealthState.FAILED
        elif HealthState.DEGRADED in unique_states:
            return HealthState.DEGRADED
        else:
            return HealthState.UNKNOWN


class ElementDeviceData:
    @staticmethod
    def build_up_sdp_cmd_data(scan_config):
        scan_config = scan_config.copy()
        sdp_scan_config = scan_config.get("sdp", {})
        if sdp_scan_config:
            scan_type = sdp_scan_config.get("scan_type")
            if scan_type:
                scan_config.pop("pointing", None)
                scan_config.pop("dish", None)
                scan_config.pop("csp", None)
                scan_config.pop("tmc", None)
            else:
                raise KeyError("SDP Subarray scan_type is empty. Command data not built up")
        else:
            # Need to check if sdp already has scan type if yes then msg showing continue with old scan .
            # and if no earlier scan exist throw error as below.
            raise KeyError("SDP configuration must be given. Aborting SDP configuration.")
        return json.dumps(scan_config)

    @staticmethod
    def build_up_csp_cmd_data(scan_config, attr_name_map, receive_addresses_map):
        '''
        Here the input data for CSP is build which is used in configuration of CSP.
        Below is the csp_config_schema variable value generated by using ska_telmodel library.
        {'id': 'sbi-mvp01-20200325-00001-science_A', 'frequencyBand': '1', 'fsp': [{'fspID': 1, 'functionMode'
        : 'CORR', 'frequencySliceID': 1, 'integrationTime': 1400, 'corrBandwidth': 0, 'channelAveragingMap':
        [[0, 2], [744, 0]], 'fspChannelOffset': 0, 'outputLinkMap': [[0, 0], [200, 1]], 'outputHost':
        [[0, '192.168.0.1'], [400, '192.168.0.2']], 'outputMac': [[0, '06-00-00-00-00-00']], 'outputPort':
        [[0, 9000, 1], [400, 9000, 1]]}, {'fspID': 2, 'functionMode': 'CORR', 'frequencySliceID': 2,
        'integrationTime': 1400, 'corrBandwidth': 0, 'channelAveragingMap': [[0, 2], [744, 0]],
        'fspChannelOffset': 744, 'outputLinkMap': [[0, 4], [200, 5]], 'outputHost': [[0, '192.168.0.3'],
        [400, '192.168.0.4']], 'outputMac': [[0, '06-00-00-00-00-01']], 'outputPort': [[0, 9000, 1],
        [400, 9000, 1]]}]}

        :return: csp confiuration schema
        '''
        scan_config = scan_config.copy()
        csp_scan_config = scan_config.get("csp", {})
        if csp_scan_config:
            scan_type = scan_config["sdp"]["scan_type"]
            if scan_type:
                # Invoke ska_telmodel library function to create csp configure schema
                if receive_addresses_map:
                    csp_config_schema = interface.make_csp_config(csp_interface_version, sdp_interface_version,
                                        scan_type, csp_scan_config, receive_addresses_map)
                    csp_config_schema = json.loads(csp_config_schema)
                else:
                    raise KeyError("Receive addresses must be given. Aborting CSP configuration.")
            else:
                raise KeyError("SDP Subarray scan_type is empty")

            if csp_config_schema:
                for key, attribute_name in attr_name_map.items():
                    csp_config_schema[key] = attribute_name
                csp_config_schema["pointing"] = scan_config["pointing"]
            else:
                raise KeyError("CSP configuration schema must be given. Aborting CSP configuration.")

        else:
            raise KeyError("CSP configuration must be given. Aborting CSP configuration.")
        return json.dumps(csp_config_schema)

    @staticmethod
    def build_up_dsh_cmd_data(scan_config, only_dishconfig_flag):
        scan_config = scan_config.copy()
        if set(["pointing", "dish"]).issubset(scan_config.keys()) or only_dishconfig_flag:
            scan_config.pop("sdp", None)
            scan_config.pop("csp", None)
            scan_config.pop("tmc", None)
            cmd_data = tango.DeviceData()
            cmd_data.insert(tango.DevString, json.dumps(scan_config))
        else:
            raise KeyError("Dish configuration must be given. Aborting Dish configuration.")
        return cmd_data


# PROTECTED REGION END #    //  SubarrayNode.additionnal_import

class SubarrayNode(SKASubarray):
    """
    Provides the monitoring and control interface required by users as well as
    other TM Components (such as OET, Central Node) for a Subarray.
    """
    # PROTECTED REGION ID(SubarrayNode.class_variable) ENABLED START #
    def command_class_object(self):
        args = (self, self.state_model, self.logger)
        self.configure_obj = self.ConfigureCommand(*args)
        self.assign_obj = self.AssignResourcesCommand(*args)
        self.release_obj = self.ReleaseAllResourcesCommand(*args)
        self.scan_obj = self.ScanCommand(*args)
        self.endscan_obj = self.EndScanCommand(*args)
        self.end_obj = self.EndCommand(*args)

    def receive_addresses_cb(self, event):
        """
        Retrieves the receiveAddresses attribute of SDP Subarray.

            :param evt: A TANGO_CHANGE event on SDP Subarray receiveAddresses attribute.

            :return: None
            """
        if not event.err:
            self._receive_addresses_map = event.attr_value.value
        else:
            log_msg = const.ERR_SUBSR_RECEIVE_ADDRESSES_SDP_SA + str(event)
            self.logger.debug(log_msg)
            self._read_activity_message = log_msg

    def health_state_cb(self, event):
        """
        Retrieves the subscribed health states, aggregates them
        to calculate the overall subarray health state.

        :param evt: A TANGO_CHANGE event on Subarray healthState.

        :return: None
        """
        exception_message = []
        exception_count = 0
        try:
            device_name = event.device.dev_name()
            # log_msg = 'Health State Attribute change event is : ' + str(event)
            # self.logger.info(log_msg)
            if not event.err:
                event_health_state = event.attr_value.value
                self.subarray_ln_health_state_map[device_name] = event_health_state

                log_message = SubarrayHealthState.generate_health_state_log_msg(
                    event_health_state, device_name, event)
                self._read_activity_message = log_message
                # self.logger.debug(log_message)
                self._health_state = SubarrayHealthState.calculate_health_state(
                    self.subarray_ln_health_state_map.values())
            else:
                log_message = const.ERR_SUBSR_SA_HEALTH_STATE + str(device_name) + str(event)
                # self.logger.debug(log_message)
                self._read_activity_message = log_message
        except Exception as except_occured:
            [exception_message, exception_count] = self._handle_generic_exception(except_occured,
                                                                                  exception_message,
                                                                                  exception_count,
                                                                                  const.ERR_AGGR_HEALTH_STATE)

    def observation_state_cb(self, evt):
        """
                Retrieves the subscribed CSP_Subarray AND SDP_Subarray  obsState.
                :param evt: A TANGO_CHANGE event on CSP and SDP Subarray obsState.
                :return: None
                """
        exception_message = []
        exception_count = 0
        try:
            log_msg = 'Observation State Attribute change event is: ' + str(evt)
            self.logger.info(log_msg)
            if not evt.err:
                self._observetion_state = evt.attr_value.value
                log_msg = 'Observation State Attribute value is: ' + str(self._observetion_state)
                self.logger.info(log_msg)
                if const.PROP_DEF_VAL_TMCSP_MID_SALN in evt.attr_name:
                    self._csp_sa_obs_state = self._observetion_state
                    self._read_activity_message = const.STR_CSP_SUBARRAY_OBS_STATE + str(
                        self._csp_sa_obs_state)
                elif const.PROP_DEF_VAL_TMSDP_MID_SALN in evt.attr_name:
                    self._sdp_sa_obs_state = self._observetion_state
                    self._read_activity_message = const.STR_SDP_SUBARRAY_OBS_STATE + str(
                        self._sdp_sa_obs_state)
                else:
                    self.logger.debug(const.EVT_UNKNOWN)
                    self._read_activity_message = const.EVT_UNKNOWN
                self.calculate_observation_state()

            else:
                log_msg = const.ERR_SUBSR_CSPSDPSA_OBS_STATE + str(evt)
                self.logger.debug(log_msg)
                self._read_activity_message = log_msg
        except KeyError as key_error:
            log_msg = const.ERR_CSPSDP_SUBARRAY_OBS_STATE + str(key_error)
            self.logger.error(log_msg)
            self._read_activity_message = const.ERR_CSPSDP_SUBARRAY_OBS_STATE + str(key_error)
        except Exception as except_occured:
            [exception_message, exception_count] = self._handle_generic_exception(except_occured,
                                                                                  exception_message,
                                                                                  exception_count,
                                                                                  const.ERR_AGGR_OBS_STATE)

    def calculate_observation_state(self):
        """
        Calculates aggregated observation state of Subarray.
        """
        self.logger.info("\n\n In Calculate observation state ------------------ JAYANT")
        pointing_state_count_track = 0
        pointing_state_count_slew = 0
        for value in list(self.dishPointingStateMap.values()):
            if value == PointingState.TRACK:
                pointing_state_count_track = pointing_state_count_track + 1
            elif value == PointingState.SLEW:
                pointing_state_count_slew = pointing_state_count_slew + 1
        if self._csp_sa_obs_state == ObsState.EMPTY and self._sdp_sa_obs_state ==\
                ObsState.EMPTY:
            if self.is_release_resources:
                print("Calling ReleaseAllResource command succeeded() method")
                self.release_obj.succeeded()
        elif self._csp_sa_obs_state == ObsState.READY and self._sdp_sa_obs_state ==\
                ObsState.READY:
            if pointing_state_count_track == len(self.dishPointingStateMap.values()):
                if self.isScanCompleted:
                    print("Calling EndScan command succeeded() method")
                    self.endscan_obj.succeeded()
                else:
                    # self._obs_state = ObsState.READY
                    # TODO:# Call ConfigureCommand's succeeded() method?
                    print("Calling Configure command succeeded() method")
                    self.configure_obj.succeeded()
        elif self._csp_sa_obs_state == ObsState.IDLE and self._sdp_sa_obs_state ==\
                ObsState.IDLE:
            if self.is_end_command:
                # End command suceess
                # self._obs_state = ObsState.IDLE
                print("Calling End command succeeded() method")
                # As a part of end command send Stop track command on dish leaf node
                self._dish_leaf_node_group.command_inout(const.CMD_STOP_TRACK)
                self.end_obj.succeeded()
            else:
                # Assign Resource command suceess
                # self._obs_state = ObsState.IDLE
                print("Calling AssignResource command succeeded() method")
                self.assign_obj.succeeded()
            # if len(self.dishPointingStateMap.values()) != 0:
            #     if pointing_state_count_track == len(self.dishPointingStateMap.values()):
            #         if self.only_dishconfig_flag == True:
            #             if not self.isScanRunning:
            #
            #                 self._obs_state = ObsState.READY
            #         else:
            #             self._dish_leaf_node_group.command_inout(const.CMD_STOP_TRACK)
            #             self._obs_state = ObsState.IDLE
            #     else:
            #         # Assign Resource command suceess
            #         # self._obs_state = ObsState.IDLE
            #         print("Calling AssignResource command succeeded() method")
            #         self.assign_obj.succeeded()

    def _handle_generic_exception(self, exception, excpt_msg_list, exception_count, read_actvity_msg):
        log_msg = read_actvity_msg + str(exception)
        self.logger.error(log_msg)
        self._read_activity_message = read_actvity_msg + str(exception)
        excpt_msg_list.append(self._read_activity_message)
        exception_count += 1
        return [excpt_msg_list, exception_count]

    def _handle_devfailed_exception(self, df, excpt_msg_list, exception_count, read_actvity_msg):
        log_msg = read_actvity_msg + str(df)
        self.logger.error(log_msg)
        self._read_activity_message = read_actvity_msg + str(df)
        excpt_msg_list.append(self._read_activity_message)
        exception_count += 1
        return [excpt_msg_list, exception_count]

    def throw_exception(self, excpt_msg_list, read_actvity_msg):
        err_msg = ''
        for item in excpt_msg_list:
            err_msg += item + "\n"
        tango.Except.throw_exception(const.STR_CMD_FAILED, err_msg, read_actvity_msg, tango.ErrSeverity.ERR)

    def create_csp_ln_proxy(self):
        """
        Creates proxy of CSP Subarray Leaf Node.
        """
        retry = 0
        proxy_created_flag = False
        while retry < 3:
            try:
                self._csp_subarray_ln_proxy = DeviceProxy(self.CspSubarrayLNFQDN)
                proxy_created_flag = True
                break
            except Exception:
                retry += 1
                continue

        return proxy_created_flag

    def create_sdp_ln_proxy(self):
        """
         Creates proxy of SDP Subarray Leaf Node.
        """
        retry = 0
        proxy_created_flag = False
        while retry < 3:
            try:
                self._sdp_subarray_ln_proxy = DeviceProxy(self.SdpSubarrayLNFQDN)
                proxy_created_flag = True
                break
            except tango.DevFailed:
                retry += 1
                continue

        return proxy_created_flag

    def _remove_subarray_dish_lns_health_states(self):
        subarray_ln_health_state_map_copy = self.subarray_ln_health_state_map.copy()
        for dev_name in subarray_ln_health_state_map_copy:
            if dev_name.startswith(const.PROP_DEF_VAL_LEAF_NODE_PREFIX):
                _ = self.subarray_ln_health_state_map.pop(dev_name)

    def _unsubscribe_resource_events(self, proxy_event_id_map):
        """
        This function unsubscribes all events given by the event ids and their
        corresponding DeviceProxy objects.

        :param proxy_event_id_map: dict
            A mapping of '<DeviceProxy>': <event_id>.

        :return: None

        """
        for device_proxy, event_id in proxy_event_id_map.items():
            try:
                device_proxy.unsubscribe_event(event_id)
            except DevFailed as dev_failed:
                log_message = "Failed to unsubscribe event {}.".format(dev_failed)
                self.logger.error(log_message )
                self._read_activity_message = log_message

    def remove_receptors_in_group(self):
        """
        Deletes tango group of the resources allocated in the subarray.

        Note: Currently there are only receptors allocated so the group contains only receptor ids.

        :param argin:
            DevVoid
        :return:
            DevVoid
        """
        if not self._dishLnVsHealthEventID or not self._dishLnVsPointingStateEventID:
            return

        try:
            self._dish_leaf_node_group.remove_all()
            log_message = const.STR_GRP_DEF + str(self._dish_leaf_node_group.get_device_list(True))
            self.logger.debug(log_message)
            self._read_activity_message = log_message
            self.logger.info(const.RECEPTORS_REMOVE_SUCCESS)
        except DevFailed as dev_failed:
            log_message = "Failed to remove receptors from the group. {}".format(dev_failed)
            self.logger.error(log_message)
            self._read_activity_message = log_message
            return

        self._unsubscribe_resource_events(self._dishLnVsHealthEventID)
        self._unsubscribe_resource_events(self._dishLnVsPointingStateEventID)

        # clearing dictonaries and lists
        self._dishLnVsHealthEventID.clear()  # Clear eventID dictionary
        self._dishLnVsPointingStateEventID.clear()  # Clear eventID dictionary
        self._health_event_id.clear()
        self._remove_subarray_dish_lns_health_states()
        self.dishPointingStateMap.clear()
        self._pointing_state_event_id.clear()
        self._dish_leaf_node_proxy.clear()
        self._receptor_id_list.clear()
        # self.set_status(const.STR_RECEPTORS_REMOVE_SUCCESS)
        self.logger.info(const.STR_RECEPTORS_REMOVE_SUCCESS)

    def release_csp_resources(self):
        """
            This function invokes releaseAllResources command on CSP Subarray via CSP Subarray Leaf
            Node.

            :param argin: DevVoid

            :return: DevVoid

        """
        try:
            self._csp_subarray_ln_proxy.command_inout(const.CMD_RELEASE_ALL_RESOURCES)
            self.logger.info(const.RELEASE_ALL_RESOURCES_CSP_SALN)
        except DevFailed as df:
            self.logger.error(const.ERR_CSP_CMD)
            self.logger.debug(df)

    def release_sdp_resources(self):
        """
            This function invokes releaseAllResources command on SDP Subarray via SDP Subarray Leaf Node.

            :param argin: DevVoid

            :return: DevVoid

        """
        try:
            self._sdp_subarray_ln_proxy.command_inout(const.CMD_RELEASE_ALL_RESOURCES)
            self.logger.info(const.RELEASE_ALL_RESOURCES_SDP_SALN)

        except DevFailed as df:
            self.logger.error(const.ERR_SDP_CMD)
            self.logger.debug(df)

    @DebugIt(show_args=True)
    def add_receptors_in_group(self, argin):
        """
        Creates a tango group of the successfully allocated resources in the subarray.
        Device proxy for each of the resources is created. The healthState and pointintgState attributes
        from all the devices in the group are subscribed so that the changes in the respective device are
        received at Subarray Node.


        Note: Currently there are only receptors allocated so the group contains only receptor ids.

        :param argin:
            DevVarStringArray. List of receptor IDs to be allocated to subarray.
            Example: ['0001', '0002']

        :return:
            DevVarStringArray. List of Resources added to the Subarray.
            Example: ['0001', '0002']
        """
        exception_count = 0
        exception_message = []
        allocation_success = []
        allocation_failure = []
        # Add each dish into the tango group

        for leafId in range(0, len(argin)):
            try:
                str_leafId = argin[leafId]
                self._dish_leaf_node_group.add(self.DishLeafNodePrefix + str_leafId)
                devProxy = DeviceProxy(self.DishLeafNodePrefix + str_leafId)
                self._dish_leaf_node_proxy.append(devProxy)
                # Update the list allocation_success with the dishes allocated successfully to subarray
                allocation_success.append(str_leafId)
                # Subscribe Dish Health State
                self._event_id = devProxy.subscribe_event(const.EVT_DISH_HEALTH_STATE,
                                                          tango.EventType.CHANGE_EVENT,
                                                          self.health_state_cb,
                                                          stateless=True)
                self._dishLnVsHealthEventID[devProxy] = self._event_id
                self._health_event_id.append(self._event_id)
                log_msg = const.STR_DISH_LN_VS_HEALTH_EVT_ID + str(self._dishLnVsHealthEventID)
                self.logger.debug(log_msg)

                # Subscribe Dish Pointing State
                self._event_id = devProxy.subscribe_event(const.EVT_DISH_POINTING_STATE,
                                                          tango.EventType.CHANGE_EVENT,
                                                          self.pointing_state_cb,
                                                          stateless=True)
                self._dishLnVsPointingStateEventID[devProxy] = self._event_id
                self._pointing_state_event_id.append(self._event_id)
                self.dishPointingStateMap[devProxy] = -1
                log_msg = const.STR_DISH_LN_VS_POINTING_STATE_EVT_ID + str(self._dishLnVsPointingStateEventID)
                self.logger.debug(log_msg)
                self._receptor_id_list.append(int(str_leafId))
                self._read_activity_message = const.STR_GRP_DEF + str(
                    self._dish_leaf_node_group.get_device_list(True))
                self._read_activity_message = const.STR_LN_PROXIES + str(self._dish_leaf_node_proxy)
                self.logger.debug(const.STR_SUBS_ATTRS_LN)
                self._read_activity_message = const.STR_SUBS_ATTRS_LN
                # TODO: FOR FUTURE REFERENCE
                # self.logger.debug(const.STR_HS_EVNT_ID +str(self._health_event_id))
                # self._read_activity_message = const.STR_HS_EVNT_ID + str(self._health_event_id)
                # Set state = ON
                # set obsState to "IDLE"
                # self._obs_state = ObsState.IDLE
                # self.set_status(const.STR_ASSIGN_RES_SUCCESS)
                self.logger.info(const.STR_ASSIGN_RES_SUCCESS)
            except DevFailed as dev_failed:
                # allocation_success.append(dev_failed)
                self.logger.exception("Receptor %s allocation failed.", str_leafId)
                [exception_message, exception_count] = self._handle_devfailed_exception(dev_failed,
                                                                                        exception_message,
                                                                                        exception_count,
                                                                                        const.ERR_ADDING_LEAFNODE)
                allocation_failure.append(str_leafId)
                # Exception Logic to remove Id from subarray group
                group_dishes = self._dish_leaf_node_group.get_device_list()
                if group_dishes.contains(self.DishLeafNodePrefix + str_leafId):
                    self._dish_leaf_node_group.remove(self.DishLeafNodePrefix + str_leafId)
                # unsubscribe event
                if self._dishLnVsHealthEventID[devProxy]:
                    devProxy.unsubscribe_event(self._dishLnVsHealthEventID[devProxy])

                if self._dishLnVsPointingStateEventID[devProxy]:
                    devProxy.unsubscribe_event(self._dishLnVsPointingStateEventID[devProxy])

            except (TypeError) as except_occurred:
                # allocation_success.append(except_occurred)
                self.logger.exception(except_occurred)
                allocation_failure.append(str_leafId)
                exception_count += 1

        # Throw Exception
        if exception_count > 0:
            exception_msg = "Failed to allocate receptors [", allocation_failure, "]"
            self.throw_exception(exception_msg, const.STR_ASSIGN_RES_EXEC)

        log_msg = "List of Resources added to the Subarray::",allocation_success
        self.logger.debug(log_msg)
        return allocation_success

    def assign_csp_resources(self, argin):
        """
        This function accepts the receptor IDs list as input and invokes the assign resources command on
        the CSP Subarray Leaf Node.

        :param argin: List of strings
            Contains the list of strings that has the resources ids. Currently this list contains only
            receptor ids.

            Example: ['0001', '0002']

        :return: List of strings.
            Returns the list of CSP resources successfully assigned to the Subarray. Currently, the
            CSPSubarrayLeafNode.AssignResources function returns void. The function only loops back
            the input argument in case of successful resource allocation, or returns exception
            object in case of failure.
        """
        arg_list = []
        json_argument = {}
        argout = []
        dish = {}
        try:
            dish[const.STR_KEY_RECEPTOR_ID_LIST] = argin
            json_argument[const.STR_KEY_DISH] = dish
            arg_list.append(json.dumps(json_argument))
            self._csp_subarray_ln_proxy.command_inout(const.CMD_ASSIGN_RESOURCES, arg_list)
            self.logger.debug(const.ASSIGN_RESOURCES_INV_CSP_SALN)
            argout = argin
        except DevFailed as df:
            # Log exception here as The callstack from this thread wont get
            # propagated to main thread.
            self.logger.exception("CSP Subarray failed to allocate resources.")
            tango.Except.re_throw_exception(df,
                "CSP Subarray failed to allocate resources.",
                "******Some problem",
                "SubarrayNode.assign_csp_resources",
                tango.ErrSeverity.ERR
            )

        # For this PI CSP Subarray Leaf Node does not return anything. So this function is
        # looping the receptor ids back.
        log_msg = "assign_csp_resources::", argout
        self.logger.debug(log_msg)
        return argout

    def assign_sdp_resources(self, argin):
        """
        This function accepts the receptor ID list as input and assigns SDP resources to SDP Subarray
        through SDP Subarray Leaf Node.

        :param argin: List of strings
            Contains the list of strings that has the resources ids. Currently
            processing block ids are passed to this function.
            Example: ['PB1', 'PB2']

        :return: List of strings.
            Returns the list of successfully assigned resources. Currently the
            SDPSubarrayLeafNode.AssignResources function returns void. Thus, this
            function just loops back the input argument in case of success or returns exception
            object in case of failure.
        """
        argout = []
        try:
            str_json_arg = json.dumps(argin)
            self._sdp_subarray_ln_proxy.command_inout(const.CMD_ASSIGN_RESOURCES, str_json_arg)
            self.logger.debug(const.ASSIGN_RESOURCES_INV_SDP_SALN)
            argout = argin
        except DevFailed as df:
            self.logger.exception("SDP Subarray failed to allocate resources.")
            tango.Except.re_throw_exception(df,
                "SDP Subarray failed to allocate resources.",
                str(df),
                "SubarrayNode.assign_sdp_resources",
                tango.ErrSeverity.ERR
            )

        # For this PI SDP Subarray Leaf Node does not return anything. So this function is
        # looping the processing block ids back.
        log_msg = "assign_sdp_resources::", argout
        self.logger.debug(log_msg)
        return argout

    def __len__(self):
        """
        Returns the number of resources currently assigned. Note that
        this also functions as a boolean method for whether there are
        any assigned resources: ``if len()``.

        :return: number of resources assigned
        :rtype: int
        """

        return len(self._receptor_id_list)

    def _configure_leaf_node(self, device_proxy, cmd_name, cmd_data):
        try:
            device_proxy.command_inout(cmd_name, cmd_data)
            log_msg = "%s configured succesfully." % device_proxy.dev_name()
            self.logger.debug(log_msg)
        except DevFailed as df:
            log_message = df[0].desc
            self._read_activity_message = log_message
            log_msg = "Failed to configure %s. %s" % (device_proxy.dev_name(), df)
            self.logger.error(log_msg)
            raise

    def _create_cmd_data(self, method_name, scan_config, *args):
        try:
            method = getattr(ElementDeviceData, method_name)
            cmd_data = method(scan_config, *args)
        except KeyError as kerr:
            log_message = kerr.args[0]
            self._read_activity_message = log_message
            self.logger.debug(log_message)
            raise
        return cmd_data

    def _configure_sdp(self, scan_configuration):
        cmd_data = self._create_cmd_data("build_up_sdp_cmd_data", scan_configuration)
        self._configure_leaf_node(self._sdp_subarray_ln_proxy, "Configure", cmd_data)

    def _configure_csp(self, scan_configuration):
        attr_name_map = {
            const.STR_DELAY_MODEL_SUB_POINT: self.CspSubarrayLNFQDN + "/delayModel",
        }
        cmd_data = self._create_cmd_data(
            "build_up_csp_cmd_data", scan_configuration, attr_name_map, self._receive_addresses_map)
        self._configure_leaf_node(self._csp_subarray_ln_proxy, "Configure", cmd_data)

    def _configure_dsh(self, scan_configuration):
        config_keys = scan_configuration.keys()
        if not set(["sdp", "csp"]).issubset(config_keys) and "dish" in config_keys:
            self.only_dishconfig_flag = True

        cmd_data = self._create_cmd_data(
            "build_up_dsh_cmd_data", scan_configuration, self.only_dishconfig_flag)

        try:
            print("self._dish_leaf_node_group", self._dish_leaf_node_group)
            self._dish_leaf_node_group.command_inout(const.CMD_CONFIGURE, cmd_data)
            self.logger.info("Configure command is invoked on the Dish Leaf Nodes Group")
            self._dish_leaf_node_group.command_inout(const.CMD_TRACK, cmd_data)
            self.logger.info('TRACK command is invoked on the Dish Leaf Node Group')
        except DevFailed as df:
            self._read_activity_message = df[0].desc
            self.logger.error(df)
            raise

    def call_end_scan_command(self):
        self.endscan_obj.do()


    def pointing_state_cb(self, evt):
        """
        Retrieves the subscribed DishMaster health state, aggregate them to evaluate
        health state of the Subarray.

        :param evt: A TANGO_CHANGE event on DishMaster healthState.

        :return: None

        """
        exception_message = []
        exception_count = 0
        try:
            log_msg= 'Pointing state Attribute change event is : ' + str(evt)
            self.logger.info(log_msg)
            if not evt.err:
                self._dish_pointing_state = evt.attr_value.value
                self.dishPointingStateMap[evt.device] = self._dish_pointing_state
                if self._dish_pointing_state == PointingState.READY:
                    str_log = const.STR_POINTING_STATE + str(evt.device) + const.STR_READY
                    self.logger.debug(str_log)
                    self._read_activity_message = str_log
                elif self._dish_pointing_state == PointingState.SLEW:
                    str_log = const.STR_POINTING_STATE + str(evt.device) + const.STR_SLEW
                    self.logger.debug(str_log)
                    self._read_activity_message = str_log
                elif self._dish_pointing_state == PointingState.TRACK:
                    str_log = const.STR_POINTING_STATE + str(evt.device) + const.STR_TRACK
                    self.logger.debug(str_log)
                    self._read_activity_message = str_log
                elif self._dish_pointing_state == PointingState.SCAN:
                    str_log = const.STR_POINTING_STATE + str(evt.device) + const.STR_SCAN
                    self.logger.debug(str_log)
                    self._read_activity_message = str_log
                else:
                    self.logger.debug(const.STR_HEALTH_STATE_UNKNOWN_VAL, evt)
                    self._read_activity_message = const.STR_POINTING_STATE_UNKNOWN_VAL + str(evt)
                self.calculate_observation_state()
            else:
                log_msg = const.ERR_SUBSR_DSH_POINTING_STATE + str(evt.errors)
                self.logger.debug(log_msg)
                self._read_activity_message = const.ERR_SUBSR_DSH_POINTING_STATE + str(evt.errors)
        except KeyError as key_err:
            log_msg = const.ERR_SETPOINTING_CALLBK + str(key_err)
            self.logger.error(log_msg)
            self._read_activity_message = const.ERR_SETPOINTING_CALLBK + str(key_err)
        except Exception as except_occured:
            [exception_message, exception_count] = self._handle_generic_exception(except_occured,
                                                                                  exception_message,
                                                                                  exception_count,
                                                                                  const.ERR_AGGR_POINTING_STATE)

    def validate_obs_state(self):
        if self._obs_state == ObsState.EMPTY:
            self.logger.info("Subarray is in required obsstate, hence resources will be assigned.")
        else:
            self.logger.error("Subarray is not in EMPTY obsState")
            self._read_activity_message = "Error in device obsState."
            raise InvalidObsStateError("Subarray is not in EMPTY obsState, \
                please check the subarray obsState")

    # PROTECTED REGION END #    //  SubarrayNode.class_variable

    # -----------------
    # Device Properties
    # -----------------

    DishLeafNodePrefix = device_property(
        dtype='str', doc="Device name prefix for the Dish Leaf Node",
    )

    CspSubarrayLNFQDN = device_property(

        dtype='str', doc="This property contains the FQDN of the CSP Subarray Leaf Node associated with the "
            "Subarray Node.",
    )

    SdpSubarrayLNFQDN = device_property(
        dtype='str', doc="This property contains the FQDN of the SDP Subarray Leaf Node associated with the "
            "Subarray Node.",
    )

    CspSubarrayFQDN = device_property(
        dtype='str',
    )

    SdpSubarrayFQDN = device_property(
        dtype='str',
    )



    # ----------
    # Attributes
    # ----------

    scanID = attribute(
        dtype='str',
        doc="ID of ongoing SCAN",
    )

    sbID = attribute(
        dtype='str',
        doc="ID of ongoing Scheduling Block",
    )

    activityMessage = attribute(
        dtype='str',
        access=AttrWriteType.READ_WRITE,
        doc="Activity Message",
    )

    receptorIDList = attribute(
        dtype=('uint16',),
        max_dim_x=100,
        doc="ID List of the Receptors assigned in the Subarray",
    )

    # ---------------
    # General methods
    # ---------------

    class InitCommand(SKASubarray.InitCommand):
        """
        A class for the TMC SubarrayNode's init_device() command.
        """
        def do(self):
            """
            Initializes the attributes and properties of the Subarray Node.

            :return: A tuple containing a return code and a string message indicating status.
            The message is for information purpose only.

            :rtype: (ReturnCode, str)
            """
            super().do()

            device = self.target
            print ("In Init:", device)
            device.set_status(const.STR_SA_INIT)
            device.SkaLevel = 2  # set SKALevel to "2"
            device._obs_mode = ObsMode.IDLE
            device.isScanRunning = False
            device.isScanCompleted = False
            device.is_end_command = False
            device.is_release_resources = False
            device._scan_id = ""
            device._sb_id = ""
            device.scan_duration = 0
            device._receptor_id_list = []
            device.dishPointingStateMap = {}
            device._dish_leaf_node_group = tango.Group(const.GRP_DISH_LEAF_NODE)
            device._dish_leaf_node_proxy = []
            device._health_event_id = []
            device._pointing_state_event_id = []
            device._dishLnVsHealthEventID = {}
            device._dishLnVsPointingStateEventID = {}
            device.subarray_ln_health_state_map = {}
            device._subarray_health_state = HealthState.OK  #Aggregated Subarray Health State
            device._csp_sa_obs_state = ObsState.IDLE
            device._sdp_sa_obs_state = ObsState.IDLE
            device._csp_sa_device_state = DevState.DISABLE
            device._sdp_sa_device_state = DevState.OFF
            device.only_dishconfig_flag = False
            device._scan_type = ''
            _state_fault_flag = False    # flag use to check whether state set to fault if exception occurs.
            device.scan_thread = None

            # Create proxy for CSP Subarray Leaf Node
            device._csp_subarray_ln_proxy = None
            device.create_csp_ln_proxy()
            # Create proxy for SDP Subarray Leaf Node
            device._sdp_subarray_ln_proxy = None
            device.create_sdp_ln_proxy()
            device._csp_sa_proxy = DeviceProxy(device.CspSubarrayFQDN)
            device._sdp_sa_proxy = DeviceProxy(device.SdpSubarrayFQDN)
            device.command_class_object()
            try:
                device.subarray_ln_health_state_map[device._csp_subarray_ln_proxy.dev_name()] = (
                    HealthState.UNKNOWN)
                # Subscribe cspsubarrayHealthState (forwarded attribute) of CspSubarray
                device._csp_subarray_ln_proxy.subscribe_event(
                    const.EVT_CSPSA_HEALTH, EventType.CHANGE_EVENT,device.health_state_cb,
                    stateless=True)
                # Subscribe cspSubarrayObsState (forwarded attribute) of CspSubarray
                device._csp_subarray_ln_proxy.subscribe_event(const.EVT_CSPSA_OBS_STATE, EventType.CHANGE_EVENT,
                                                              device.observation_state_cb, stateless=True)
                # device._csp_sa_proxy.subscribe_event('state', EventType.CHANGE_EVENT,
                #                                      device.device_state_cb, stateless=True)

                device.set_status(const.STR_CSP_SA_LEAF_INIT_SUCCESS)
                self.logger.info(const.STR_CSP_SA_LEAF_INIT_SUCCESS)
            except DevFailed as dev_failed:
                log_msg = const.ERR_SUBS_CSP_SA_LEAF_ATTR + str(dev_failed)
                self.logger.error(log_msg)
                device._read_activity_message = log_msg
                device.set_state(DevState.FAULT)  ## state machine only?
                _state_fault_flag = True
                device.set_status(const.ERR_SUBS_CSP_SA_LEAF_ATTR)
                self.logger.error(const.ERR_CSP_SA_LEAF_INIT)

            try:
                device.subarray_ln_health_state_map[device._sdp_subarray_ln_proxy.dev_name()] = (
                    HealthState.UNKNOWN)
                # Subscribe sdpSubarrayHealthState (forwarded attribute) of SdpSubarray
                device._sdp_subarray_ln_proxy.subscribe_event(const.EVT_SDPSA_HEALTH, EventType.CHANGE_EVENT,
                                                            device.health_state_cb, stateless=True)
                # Subscribe sdpSubarrayObsState (forwarded attribute) of SdpSubarray
                device._sdp_subarray_ln_proxy.subscribe_event(const.EVT_SDPSA_OBS_STATE, EventType.CHANGE_EVENT,
                                                            device.observation_state_cb, stateless=True)
                # device._sdp_sa_proxy.subscribe_event('state', EventType.CHANGE_EVENT,
                #                                    device.device_state_cb, stateless=True)
                # Subscribe ReceiveAddresses of SdpSubarray
                device._sdp_sa_proxy.subscribe_event("receiveAddresses", EventType.CHANGE_EVENT,
                                                   device.receive_addresses_cb, stateless=True)

                device.set_status(const.STR_SDP_SA_LEAF_INIT_SUCCESS)
            except DevFailed as dev_failed:
                log_msg = const.ERR_SUBS_SDP_SA_LEAF_ATTR + str(dev_failed)
                self.logger.error(log_msg)
                device._read_activity_message = log_msg
                device.set_state(DevState.FAULT)  ## state machine only?
                _state_fault_flag = True
                device.set_status(const.ERR_SUBS_SDP_SA_LEAF_ATTR)

            if _state_fault_flag:
                message = const.ERR_SA_INIT
                return_code = ResultCode.FAILED
            else:
                message = const.STR_SA_INIT_SUCCESS
                return_code = ResultCode.OK

            device._read_activity_message = message
            self.logger.info(message)
            return (return_code, message)

    def always_executed_hook(self):
        """ Internal construct of TANGO. """
        # PROTECTED REGION ID(SubarrayNode.always_executed_hook) ENABLED START #
        # PROTECTED REGION END #    //  SubarrayNode.always_executed_hook

    def delete_device(self):
        # PROTECTED REGION ID(SubarrayNode.delete_device) ENABLED START #
        """ Internal construct of TANGO. """
        # PROTECTED REGION END #    //  SubarrayNode.delete_device

    # ------------------
    # Attributes methods
    # ------------------

    def read_scanID(self):
        """ Internal construct of TANGO. Returns the Scan ID.

        EXAMPLE: 123
        Where 123 is a Scan ID from configuration json string.
        """
        # PROTECTED REGION ID(SubarrayNode.scanID_read) ENABLED START #
        return self._scan_id
        # PROTECTED REGION END #    //  SubarrayNode.scanID_read

    def read_sbID(self):
        """ Internal construct of TANGO. Returns the scheduling block ID. """
        # PROTECTED REGION ID(SubarrayNode.sbID_read) ENABLED START #
        return self._sb_id
        # PROTECTED REGION END #    //  SubarrayNode.sbID_read

    def read_activityMessage(self):
        """ Internal construct of TANGO. Returns activityMessage.
        Example: "Subarray node is initialized successfully"
        //result occured after initialization of device.
        """
        # PROTECTED REGION ID(SubarrayNode.activityMessage_read) ENABLED START #
        return self._read_activity_message
        # PROTECTED REGION END #    //  SubarrayNode.activityMessage_read

    def write_activityMessage(self, value):
        """ Internal construct of TANGO. Sets the activityMessage. """
        # PROTECTED REGION ID(SubarrayNode.activityMessage_write) ENABLED START #
        self._read_activity_message = value
        # PROTECTED REGION END #    //  SubarrayNode.activityMessage_write

    def read_receptorIDList(self):
        """ Internal construct of TANGO. Returns the receptor IDs allocated to the Subarray.
         """
        # PROTECTED REGION ID(SubarrayNode.receptorIDList_read) ENABLED START #
        return self._receptor_id_list
        # PROTECTED REGION END #    //  SubarrayNode.receptorIDList_read

    # --------
    # Commands
    # --------

    class ConfigureCommand(SKASubarray.ConfigureCommand):
        """
        A class for SubarrayNode's Configure() command.
        """
        def do(self, argin):
            """
            Configures the resources assigned to the Subarray.The configuration data for SDP, CSP and Dish is
            extracted out of the input configuration string and relayed to the respective underlying devices (SDP
            Subarray Leaf Node, CSP Subarray Leaf Node and Dish Leaf Node).

            :param argin: DevString.
            JSON string that includes pointing parameters of Dish - Azimuth and Elevation Angle, CSP
            Configuration and SDP Configuration parameters.
            JSON string example is:
            {"pointing":{"target":{"system":"ICRS","name":"Polaris Australis","RA":"21:08:47.92","dec":"-88:57:22.9"}},
            "dish":{"receiverBand":"1"},"csp":{"id":"sbi-mvp01-20200325-00001-science_A","frequencyBand":"1",
            "fsp":[{"fspID":1,"functionMode":"CORR","frequencySliceID":1,"integrationTime":1400,"corrBandwidth":0}]},
            "sdp":{"scan_type":"science_A"},"tmc":{"scanDuration":10.0}}
            CSP block in json string is as per earlier implementation and not aligned to SP-872
            Note: While invoking this command from JIVE, provide above JSON string without any space.

            :return: A tuple containing a return code and a string message indicating status.
             The message is for information purpose only.

            :rtype: (ReturnCode, str)
            """
            device = self.target

            self.logger.info(const.STR_CONFIGURE_CMD_INVOKED_SA)
            log_msg = const.STR_CONFIGURE_IP_ARG + str(argin)
            self.logger.info(log_msg)
            device.set_status(const.STR_CONFIGURE_CMD_INVOKED_SA)
            device._read_activity_message = const.STR_CONFIGURE_CMD_INVOKED_SA

            try:
                scan_configuration = json.loads(argin)
            except json.JSONDecodeError as jerror:
                log_message = const.ERR_INVALID_JSON + str(jerror)
                self.logger.error(log_message)
                device._read_activity_message = log_message
                tango.Except.throw_exception(const.STR_CMD_FAILED, log_message,
                                             const.STR_CONFIGURE_EXEC, tango.ErrSeverity.ERR)

            tmc_configure = scan_configuration["tmc"]
            device.scan_duration = int(tmc_configure["scanDuration"])
            device._configure_csp(scan_configuration)
            device._configure_sdp(scan_configuration)
            device._configure_dsh(scan_configuration)

            message = "Configure command invoked"
            self.logger.info(message)
            return (ResultCode.STARTED, message)

    def call_stop_track_command(self):
        print("Before Stop track")
        print("device._dish_leaf_node_group:", self._dish_leaf_node_group)
        # TODO: Why we are calling stop track as group command
        self._dish_leaf_node_group.command_inout(const.CMD_STOP_TRACK)
        print("After stop track")
        self.logger.info(const.STR_CMD_STOP_TRACK_INV_DLN)

    class EndCommand(SKASubarray.EndCommand):
        """
        A class for SubarrayNode's End() command.
        """
        def do(self):
            """
            This command on Subarray Node invokes EndSB command on CSP Subarray Leaf Node and SDP
            Subarray Leaf Node, and stops tracking of all the assigned dishes.

            :return: A tuple containing a return code and a string message indicating status.
            The message is for information purpose only.

            :rtype: (ResultCode, str)
            """
            device = self.target
            exception_message = []
            exception_count = 0
            try:
                self.logger.info("End command invoked on SubarrayNode.")
                # if device._obs_state == ObsState.READY:
                device._sdp_subarray_ln_proxy.command_inout(const.CMD_ENDSB)
                self.logger.info(const.STR_CMD_ENDSB_INV_SDP)
                device._csp_subarray_ln_proxy.command_inout(const.CMD_GOTOIDLE)
                self.logger.info(const.STR_CMD_GOTOIDLE_INV_CSP)
                # TODO: Uncomment this after resolving issues
                device.call_stop_track_command()
                device._read_activity_message = const.STR_ENDSB_SUCCESS
                self.logger.info(const.STR_ENDSB_SUCCESS)
                device.set_status(const.STR_ENDSB_SUCCESS)
                device.is_end_command = True
                return (ResultCode.OK, const.STR_ENDSB_SUCCESS)
                # else:
                #     device._read_activity_message = const.ERR_DEVICE_NOT_READY
                #     self.logger.error(const.ERR_DEVICE_NOT_READY)
            except DevFailed as dev_failed:
                [exception_message, exception_count] = device._handle_devfailed_exception(dev_failed,
                                                exception_message, exception_count, const.ERR_ENDSB_INVOKING_CMD)
            except Exception as except_occurred:
                [exception_message, exception_count] = device._handle_generic_exception(except_occurred,
                                                exception_message, exception_count, const.ERR_ENDSB_INVOKING_CMD)

            # TODO: For Future use
            # throw exception:
            if exception_count > 0:
                device.throw_exception(exception_message, const.STR_ENDSB_EXEC)
                return (ResultCode.FAILED, const.ERR_ENDSB_INVOKING_CMD)
            # PROTECTED REGION END #    //  SubarrayNode.EndSB

    class TrackCommand(ResponseCommand):
        """
        A class for SubarrayNode's Track command.
        """
        # def check_allowed(self):
        #     """
        #     Whether this command is allowed to be run in current device
        #     state
        #
        #     :return: True if this command is allowed to be run in
        #         current device state
        #     :rtype: boolean
        #     :raises: DevFailed if this command is not allowed to be run
        #         in current device state
        #     """
        #     if not self.state_model.dev_state in [
        #         DevState.FAULT, DevState.UNKNOWN, DevState.DISABLE,
        #     ]:
        #         tango_raise(
        #             "Track() is not allowed in current state"
        #         )
        #
        #     return True

        def check_allowed(self):
            """
            Whether this command is allowed to be run in current device
            state

            :return: True if this command is allowed to be run in
                current device state
            :rtype: boolean
            :raises: DevFailed if this command is not allowed to be run
                in current device state
            """
            if self.state_model.dev_state in [DevState.FAULT, DevState.UNKNOWN, DevState.DISABLE]:
                tango.Except.throw_exception("Command TrackCommand is not allowed in current state.",
                                             "Failed to invoke TrackCommand command on DishLeafNode.",
                                             "SubarrayNode.TrackComamnd()",
                                             tango.ErrSeverity.ERR)
            return True

        def do(self, argin):
            """ Invokes Track command on the Dishes assigned to the Subarray.

            :param argin: DevString

            Example:
            radec|21:08:47.92|-88:57:22.9 as argin
            Argin to be provided is the Ra and Dec values where first value is tag that is radec, second value is Ra
            in Hr:Min:Sec, and third value is Dec in Deg:Min:Sec.

            :return: A tuple containing a return code and a string message indicating status.
            The message is for information purpose only.

            :rtype: (ResultCode, str)

            """
            device = self.target
            exception_message = []
            exception_count = 0
            log_msg = "Track:", argin
            self.logger.debug(log_msg)
            try:
                device._read_activity_message = const.STR_TRACK_IP_ARG + argin
                # set obsState to CONFIGURING when the configuration is started
                # self._obs_state = ObsState.CONFIGURING
                cmd_input = []
                cmd_input.append(argin)
                cmdData = tango.DeviceData()
                cmdData.insert(tango.DevVarStringArray, cmd_input)
                device._dish_leaf_node_group.command_inout(const.CMD_TRACK, cmdData)
                # set obsState to READY when the configuration is completed
                # self._obs_state = ObsState.READY
                device._scan_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(4))
                #self._sb_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(4))
                self.logger.info(const.STR_TRACK_CMD_INVOKED_SA)
                return (ResultCode.OK, const.STR_TRACK_CMD_INVOKED_SA)
            except tango.DevFailed as devfailed:
                exception_message.append(const.ERR_TRACK_CMD + ": " + \
                               str(devfailed.args[0].desc))
                exception_count += 1
                return (ResultCode.FAILED, const.ERR_TRACK_CMD)
            except Exception as except_occured:
                str_log = const.ERR_TRACK_CMD + "\n" + str(except_occured)
                self.logger.error(str_log)
                self._read_activity_message = const.ERR_TRACK_CMD + str(except_occured)
                self.logger.error(const.ERR_TRACK_CMD)
                exception_message.append(const.ERR_TRACK_CMD + ": " + \
                                 str(except_occured.args[0].desc))
                exception_count += 1
                return (ResultCode.FAILED, const.ERR_TRACK_CMD)

            # TODO: For Future use
            # # throw exception
            # if exception_count > 0:
            #     err_msg = ' '
            #     for item in exception_message:
            #         err_msg += item + "\n"
            #     tango.Except.throw_exception(const.STR_CMD_FAILED, err_msg,
            #                                  const.STR_TRACK_EXEC, tango.ErrSeverity.ERR)
            # PROTECTED REGION END #    //  SubarrayNode.Track

    def is_Track_allowed(self):
        """
        Whether this command is allowed to be run in current device
        state
        :return: True if this command is allowed to be run in
            current device state
        :rtype: boolean
        :raises: DevFailed if this command is not allowed to be run
            in current device state
        """
        handler = self.get_command_object("Track")
        return handler.check_allowed()


    @command(
        dtype_in='str',
        doc_in="Initial Pointing parameters of Dish - Right Ascension and Declination coordinates.",
        dtype_out="DevVarLongStringArray",
        doc_out="[ResultCode, information-only string]",
    )
    def Track(self, argin):
        """
        Invokes Track command on the Dishes assigned to the Subarray.
        """
        handler = self.get_command_object("Track")
        (result_code, message) = handler(argin)
        return [[result_code], [message]]

    class OnCommand(SKASubarray.OnCommand):
        """
        A class for the SubarrayNode's On() command.
        """
        def do(self):
            """
            Stateless hook for On() command functionality.

            :return: A tuple containing a return code and a string
                message indicating status. The message is for
                information purpose only.
            :rtype: (ResultCode, str)
            """
            device = self.target
            # device._csp_subarray_ln_proxy.command_inout(const.CMD_ON)
            # device._sdp_subarray_ln_proxy.command_inout(const.CMD_ON)
            device._csp_subarray_ln_proxy.On()
            device._sdp_subarray_ln_proxy.On()
            message = "On command completed OK"
            self.logger.info(message)
            return (ResultCode.OK, message)

    class OffCommand(SKASubarray.OffCommand):
        """
        A class for the SubarrayNodes's Off() command.
        """
        def do(self):
            """
            Stateless hook for Off() command functionality.

            :return: A tuple containing a return code and a string message indicating status.
            The message is for information purpose only.

            :rtype: (ResultCode, str)
            """
            device = self.target
            # device._csp_subarray_ln_proxy.command_inout(const.CMD_OFF)
            # device._sdp_subarray_ln_proxy.command_inout(const.CMD_OFF)
            device._csp_subarray_ln_proxy.Off()
            device._sdp_subarray_ln_proxy.Off()
            message = "Off command completed OK"
            self.logger.info(message)
            return (ResultCode.OK, message)

    class ScanCommand(SKASubarray.ScanCommand):
        """
        A class for SubarrayNode's Scan() command.
        """

        def do(self, argin):
            """
            This command accepts id as input. And it Schedule scan on subarray
            from where scan command is invoked on respective CSP and SDP subarray node for the
            provided interval of time. It checks whether the scan is already in progress. If yes it
            throws error showing duplication of command.

            :param argin: DevString. JSON string containing id.

            JSON string example as follows:

            {"id": 1}

            Note: Above JSON string can be used as an input argument while invoking this command from JIVE.

            :return: A tuple containing a return code and a string message indicating status.
            The message is for information purpose only.

            :rtype: (ReturnCode, str)
            """
            device = self.target
            exception_count = 0
            exception_message = []
            try:
                log_msg = const.STR_SCAN_IP_ARG + str(argin)
                self.logger.info(log_msg)
                device._read_activity_message = log_msg
                device.isScanRunning = True
                # Invoke scan command on Sdp Subarray Leaf Node with input argument as scan id
                device._sdp_subarray_ln_proxy.command_inout(const.CMD_SCAN, argin)
                self.logger.info(const.STR_SDP_SCAN_INIT)
                device._read_activity_message = const.STR_SDP_SCAN_INIT
                # Invoke Scan command on CSP Subarray Leaf Node
                csp_argin = [argin]
                device._csp_subarray_ln_proxy.command_inout(const.CMD_START_SCAN, csp_argin)
                self.logger.info(const.STR_CSP_SCAN_INIT)
                device._read_activity_message = const.STR_CSP_SCAN_INIT

                # TODO: Update observation state aggregation logic
                # if self._csp_sa_obs_state == ObsState.IDLE and self._sdp_sa_obs_state ==\
                #         ObsState.IDLE:
                #     if len(self.dishPointingStateMap.values()) != 0:
                #         self.calculate_observation_state()

                device.set_status(const.STR_SA_SCANNING)
                self.logger.info(const.STR_SA_SCANNING)
                device._read_activity_message = const.STR_SCAN_SUCCESS

                # Once Scan Duration is complete call EndScan Command
                self.logger.info("Starting Scan Thread")
                device.scan_thread = threading.Timer(device.scan_duration, device.call_end_scan_command)
                device.scan_thread.start()
                self.logger.info("Scan thread started")

                return (ResultCode.STARTED, const.STR_SCAN_SUCCESS)

            except DevFailed as dev_failed:
                [exception_message, exception_count] = device._handle_devfailed_exception(dev_failed,
                                                                                          exception_message,
                                                                                          exception_count,
                                                                                          const.ERR_SCAN_CMD)

            except Exception as except_occurred:
                [exception_message, exception_count] = device._handle_generic_exception(except_occurred,
                                                                                        exception_message,
                                                                                        exception_count,
                                                                                        const.ERR_SCAN_CMD)

            # Throw Exception
            if exception_count > 0:
                device.throw_exception(exception_message, const.STR_SCAN_EXEC)
                return (ResultCode.FAILED, const.ERR_SCAN_CMD)

    class EndScanCommand(SKASubarray.EndScanCommand):
        """
        A class for SubarrayNode's EndScan() command.
        """

        def do(self):
            """
            Ends the scan. It is invoked on subarray after completion of the scan duration. It can
            also be invoked by an external client while a scan is in progress, Which stops the scan
            immediately irrespective of the provided scan duration.

            :return: A tuple containing a return code and a string message indicating status.
            The message is for information purpose only.

            :rtype: (ReturnCode, str)
            """
            device = self.target
            exception_count = 0
            exception_message = []

            try:
                if device.scan_thread:
                    if device.scan_thread.is_alive():
                        device.scan_thread.cancel()  # stop timer when EndScan command is called

                # if self._obs_state == ObsState.SCANNING:
                device.isScanRunning = False
                device.isScanCompleted = True
                # Invoke EndScan command on SDP Subarray Leaf Node
                device._sdp_subarray_ln_proxy.command_inout(const.CMD_END_SCAN)
                self.logger.debug(const.STR_SDP_END_SCAN_INIT)
                device._read_activity_message = const.STR_SDP_END_SCAN_INIT

                # Invoke EndScan command on CSP Subarray Leaf Node
                device._csp_subarray_ln_proxy.command_inout(const.CMD_END_SCAN)
                self.logger.debug(const.STR_CSP_END_SCAN_INIT)
                device._read_activity_message = const.STR_CSP_END_SCAN_INIT
                device._scan_id = ""

                # if device._csp_sa_obs_state == ObsState.IDLE and device._sdp_sa_obs_state ==\
                #         ObsState.IDLE:
                #     if len(device.dishPointingStateMap.values()) != 0:
                #         device.calculate_observation_state()

                device.set_status(const.STR_SCAN_COMPLETE)
                self.logger.info(const.STR_SCAN_COMPLETE)
                device._read_activity_message = const.STR_END_SCAN_SUCCESS
                return (ResultCode.OK, const.STR_END_SCAN_SUCCESS)

            except DevFailed as dev_failed:
                [exception_message, exception_count] = device._handle_devfailed_exception(dev_failed,
                                                                                          exception_message,
                                                                                          exception_count,
                                                                                          const.ERR_END_SCAN_CMD_ON_GROUP)

            except Exception as except_occurred:
                [exception_message, exception_count] = device._handle_generic_exception(except_occurred,
                                                                                        exception_message,
                                                                                        exception_count,
                                                                                        const.ERR_END_SCAN_CMD)

            # Throw Exception
            if exception_count > 0:
                device.throw_exception(exception_message, const.STR_END_SCAN_EXEC)
                return (ResultCode.FAILED, const.ERR_END_SCAN_CMD)

    class AssignResourcesCommand(SKASubarray.AssignResourcesCommand):
        """
        A class for SubarrayNode's AssignResources() command.
        """

        def do(self, argin):
            """
            Assigns resources to the subarray. It accepts receptor id list as well as SDP resources string
            as a DevString. Upon successful execution, the 'receptorIDList' attribute of the
            subarray is updated with the list of receptors and SDP resources string is pass to SDPSubarrayLeafNode,
            and returns list of assigned resources as well as passed SDP string as a DevString.

            Note: Resource allocation for CSP and SDP resources is also implemented but
            currently CSP accepts only receptorIDList and SDP accepts resources allocated to it.

            :param argin:
            DevVarString.

            Example:

            {"dish":{"receptorIDList":["0002","0001"]},"sdp":{"id":
            "sbi-mvp01-20200325-00001","max_length":100.0,"scan_types":[{"id":"science_A",
            "coordinate_system":"ICRS","ra":"02:42:40.771","dec":"-00:00:47.84","channels":[{"count":744,"start":0,"stride":2,"freq_min":0.35e9,"freq_max":0.368e9,
            "link_map":[[0,0],[200,1],[744,2],[944,3]]},{"count":744,"start":2000,"stride":1,
            "freq_min":0.36e9,"freq_max":0.368e9,"link_map":[[2000,4],[2200,5]]}]},{"id":
            "calibration_B","coordinate_system":"ICRS","ra":"12:29:06.699","dec":"02:03:08.598",
            "channels":[{"count":744,"start":0,"stride":2,"freq_min":0.35e9,
            "freq_max":0.368e9,"link_map":[[0,0],[200,1],[744,2],[944,3]]},{"count":744,
            "start":2000,"stride":1,"freq_min":0.36e9,"freq_max":0.368e9,"link_map":[[2000,4],
            [2200,5]]}]}],"processing_blocks":[{"id":"pb-mvp01-20200325-00001","workflow":
            {"type":"realtime","id":"vis_receive","version":"0.1.0"},"parameters":{}},
            {"id":"pb-mvp01-20200325-00002","workflow":{"type":"realtime","id":"test_realtime",
            "version":"0.1.0"},"parameters":{}},{"id":"pb-mvp01-20200325-00003","workflow":
            {"type":"batch","id":"ical","version":"0.1.0"},"parameters":{},"dependencies":[
            {"pb_id":"pb-mvp01-20200325-00001","type":["visibilities"]}]},{"id":
            "pb-mvp01-20200325-00004","workflow":{"type":"batch","id":"dpreb","version":"0.1.0"},
            "parameters":{},"dependencies":[{"pb_id":"pb-mvp01-20200325-00003","type":
            ["calibration"]}]}]}}


            :return: A tuple containing a return code and string of Resources added to the Subarray.
                Example of string of Resources :
                    ["0001","0002"]
                as argout if allocation successful.

            :rtype: (ResultCode, str)

            :throws: DevFailed.

            """

            # exception_count = 0
            # exception_message = []
            device = self.target
            argout = []
            # Validate if Subarray is in IDLE obsState
            # TODO: Need to get idea if this is required?
            # try:
            #     device.validate_obs_state()
            # except InvalidObsStateError as error:
            #     self.logger.exception(error)
            #     tango.Except.throw_exception("Subarray is not in IDLE obsState",
            #                     "SubarrayNode raised InvalidObsStateError in AssignResources command",
            #                     "subarraynode.AssignResources()", tango.ErrSeverity.ERR)

            # 1. Argument validation
            try:
                # Allocation success and failure lists
                resources = json.loads(argin)
                receptor_list = resources["dish"]["receptorIDList"]
                sdp_resources = resources.get("sdp")
                device._sb_id = resources["sdp"]["id"]

                for leafId in range(0, len(receptor_list)):
                    float(receptor_list[leafId])
                # validation of SDP and CSP resources yet to be implemented as of now reources are not present.
            except json.JSONDecodeError as json_error:
                self.logger.exception(const.ERR_INVALID_JSON)
                message = const.ERR_INVALID_JSON + json_error
                device._read_activity_message = message
                tango.Except.throw_exception(const.STR_CMD_FAILED, message,
                                             const.STR_ASSIGN_RES_EXEC, tango.ErrSeverity.ERR)
            except ValueError as value_error:
                self.logger.exception(const.ERR_INVALID_DATATYPE)
                message = const.ERR_INVALID_DATATYPE + value_error
                device._read_activity_message = message
                tango.Except.throw_exception(const.STR_CMD_FAILED, message,
                                             const.STR_ASSIGN_RES_EXEC, tango.ErrSeverity.ERR)

            with ThreadPoolExecutor(3) as executor:
                # 2.1 Create group of receptors
                self.logger.debug(const.STR_DISH_ALLOCATION)
                dish_allocation_status = executor.submit(device.add_receptors_in_group, receptor_list)

                # 2.2. Add resources in CSP subarray
                self.logger.debug(const.STR_CSP_ALLOCATION)
                csp_allocation_status = executor.submit(device.assign_csp_resources, receptor_list)

                # 2.3. Add resources in SDP subarray
                self.logger.debug(const.STR_SDP_ALLOCATION)
                sdp_allocation_status = executor.submit(device.assign_sdp_resources, sdp_resources)

                # 2.4 wait for result
                while (dish_allocation_status.done() is False or
                       csp_allocation_status.done() is False or
                       sdp_allocation_status.done() is False
                ):
                    pass

                # 2.5. check results
                try:
                    dish_allocation_result = dish_allocation_status.result()
                    log_msg = const.STR_DISH_ALLOCATION_RESULT + str(dish_allocation_result)
                    self.logger.debug(log_msg)
                    dish_allocation_result.sort()
                    self.logger.debug("Dish group is created successfully")
                except DevFailed as df:
                    self.logger.exception("Dish allocation failed.")
                    tango.Except.re_throw_exception(
                        df,
                        "Dish allocation failed."
                        "SubarrayNode.AssignResources",
                        tango.ErrSeverity.ERR
                    )

                try:
                    csp_allocation_result = csp_allocation_status.result()
                    log_msg = const.STR_CSP_ALLOCATION_RESULT + str(csp_allocation_result)
                    self.logger.debug(log_msg)

                    csp_allocation_result.sort()
                    # assert csp_allocation_result == receptor_list
                    self.logger.info("Assign Resources on CSPSubarray successful")
                except DevFailed as df:
                    # The exception is already logged so not logged again.
                    tango.Except.re_throw_exception(
                        df,
                        "CSP allocation failed."
                        "SubarrayNode.AssignResources",
                        tango.ErrSeverity.ERR
                    )
                # except AssertionError as error:
                #     self.logger.exception("Failed to assign CSP resources: actual %s != %s expected",
                #         csp_allocation_result, receptor_list)
                #     tango.Except.throw_exception(
                #         "Assign resources failed on CspSubarrayLeafNode",
                #         str(csp_allocation_result),
                #         "subarraynode.AssignResources()",
                #         tango.ErrSeverity.ERR)

                try:
                    sdp_allocation_result = sdp_allocation_status.result()
                    log_msg = const.STR_SDP_ALLOCATION_RESULT + str(sdp_allocation_result)
                    self.logger.debug(log_msg)
                    self.logger.info("Assign Resources on SDPSubarray successful")
                except DevFailed as df:
                    # The exception is already logged so not logged again.
                    tango.Except.re_throw_exception(
                        df,
                        "SDP allocation failed."
                        "SubarrayNode.AssignResources",
                        tango.ErrSeverity.ERR
                    )

                # sdp_allocation_result = sdp_allocation_status.result()
                # log_msg = const.STR_SDP_ALLOCATION_RESULT + str(sdp_allocation_result)
                # self.logger.debug(log_msg)

                # try:
                #     assert sdp_allocation_result == sdp_resources
                #     self.logger.info("Assign Resources on SDPSubarray successful")
                # except AssertionError as error:
                #     self.logger.exception("Failed to assign SDP resources: actual %s != %s expected",
                #         sdp_allocation_result, sdp_resources)
                #     tango.Except.throw_exception(
                #         "Assign resources failed on CspSubarrayLeafNode",
                #         str(sdp_allocation_result),
                #         "subarraynode.AssignResources()",
                #         tango.ErrSeverity.ERR)
                # TODO: For future use
                # if(dish_allocation_result == receptor_list and
                #     csp_allocation_result == receptor_list and
                #     sdp_allocation_result == sdp_resources
                #   ):
                #     # Currently sending dish allocation and SDP allocation results.
                #     argout = dish_allocation_result
                # else:
                #     argout = []

            argout = dish_allocation_result
            log_msg = "assign_resource_argout", argout
            self.logger.debug(log_msg)
            message = str(argout)
            return (ResultCode.OK, message)

        # def succeeded(self):
        #     """
        #     Action to take on successful completion of a resourcing
        #     command.
        #     """
        #     action = "resourcing_succeeded_some_resources"
        #     self.state_model.perform_action(action)

    class ReleaseAllResourcesCommand(SKASubarray.ReleaseAllResourcesCommand):
        """
        A class for SKASubarray's ReleaseAllResources() command.
        """

        def do(self):
            """
            It checks whether all resources are already released. If yes then it throws error while
            executing command. If not it Releases all the resources from the subarray i.e. Releases
            resources from TMC Subarray Node, CSP Subarray and SDP Subarray. If the command
            execution fails, array of receptors(device names) which are failed to be released from the
            subarray, is returned to Central Node. Upon successful execution, all the resources of a given
            subarray get released and empty array is returned. Selective release is not yet supported.

            :return: A tuple containing a return code and "[]" as a string on successful release all resources.
            Example: "[]" as string on successful release all resources.

            :rtype: (ResultCode, str)

            """
            # try:
            #     assert self._dishLnVsHealthEventID != {}, const.RESOURCE_ALREADY_RELEASED
            # except AssertionError as assert_err:
            #     log_message = const.ERR_RELEASE_RES_CMD + str(assert_err)
            #     self.logger.error(log_message)
            #     self._read_activity_message = log_message
            #     tango.Except.throw_exception(const.STR_CMD_FAILED, log_message,
            #                                  const.STR_RELEASE_ALL_RES_EXEC, tango.ErrSeverity.ERR)

            device = self.target
            self.logger.info(const.STR_DISH_RELEASE)
            device.remove_receptors_in_group()
            self.logger.info(const.STR_CSP_RELEASE)
            device.release_csp_resources()
            self.logger.info(const.STR_SDP_RELEASE)
            device.release_sdp_resources()
            device._scan_id = ""
            # For now cleared SB ID in ReleaseAllResources command. When the EndSB command is implemented,
            # It will be moved to that command.
            device._sb_id = ""
            device.is_release_resources = True
            argout = device._dish_leaf_node_group.get_device_list(True)
            log_msg = "Release_all_resources:", argout
            self.logger.debug(log_msg)
            message = str(argout)
            return (ResultCode.OK, message)
            # return (ResultCode.OK, "Release_all_resources succeeful")

    def init_command_objects(self):
        """
        Initialises the command handlers for commands supported by this
        device.
        """
        super().init_command_objects()
        args = (self, self.state_model, self.logger)
        self.register_command_object("Track",self.TrackCommand(*args))
        # In order to pass self = subarray node as target device, the assign and release resource commands
        # are registered and inherited from SKASubarray
        self.register_command_object("AssignResources",self.AssignResourcesCommand(*args))
        self.register_command_object("ReleaseAllResources",self.ReleaseAllResourcesCommand(*args))


# ----------
# Run server
# ----------

def main(args=None, **kwargs):
    # PROTECTED REGION ID(SubarrayNode.main) ENABLED START #
    """
    Runs the SubarrayNode.
    :param args: Arguments internal to TANGO
    :param kwargs: Arguments internal to TANGO
    :return: SubarrayNode TANGO object.
    """
    return run((SubarrayNode,), args=args, **kwargs)
    # PROTECTED REGION END #    //  SubarrayNode.main

if __name__ == '__main__':
    main()
